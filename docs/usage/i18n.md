# Translations

Two distinct mechanisms are used depending on what we are handling:
1)	translation of the terms related to a class;
2)	translation of object fields values (instance).



## Translation of the terms related to a class

Each package can have an optional folder named ‘i18n’. If existing, this folder must contain a subfoler for each defined language. Subfolders use the ISO 639-1 language code as naming convention (ex. : fr or zh). Inside those folders, for each class, translations are stored in `.json` files which prefixes are identical to the class they refer to (ex. : `Student.json`).

Those translation files use UTF-8 encoding and JSON format, and contain the translation terms of all items that might be translated (attributes ‘label’, ‘help’ and ‘selection’).

The translation file has the `name` and the `plural` of the name of the class, as well as a `description` for it.  

The **model** section which consist of a map of all the field names that are present in the class, to which is associated a list of attributes with their related translations. 

Possible attributes are :   

* `label` attribute is the name of the field that we want the user to see and it must start with a capital letter. 
* `help` attribute is considered an additional information or a small brief for the field, to assist users in understanding the use of it. This attribute should start with a capital letter and end with either ".", "?" or "!". 
* `selection` attribute is usually added for the "type" field of the class, which allows the translation of the available options of the field.


The **view** section that translates all the section names of the tabs or the groups, if present in the form view. This is done by simply adding the "id" of the section and assigning a label for it.  

The **error** section is used for translating the form validation (Usually added for the Login/Sign Up form).


### Example of french (fr) translation using i18n

```json
{
	"name": "Règle de Tva",
	"plural": "Règles de Tva",
	"description": "Les règles comptables permettent de préciser sur quel compte une opération doit être imputée.",
	"model": {
		"name":{"label":"Nom", "help": "Nom de la règle comptable."},
		"description":{"label":"Description", "help": "Brève description de la règle pour servir de mémo."},
		"type":{"label":"Type", "help": "Type d'opération auquel cette règle se rapporte.", "selection": {"purchase": "achat", "sale": "vente"} },
        "vat_rule_id":{"label":"Règle de TVA", "help": "Règle de TVA à laquelle cette ligne est liée."},
        "accounting_rule_line_ids":{"label":"Lignes liées à cette règle", "help": "Lignes liées à cette règle."}
	},
	"view": {
		"section.accounting_rules_section": {"label": "Détails"},
		"section.accounting_rulelines": {"label": "Ligne de règle comptable"}
	},
	"error": {
	
	}
}
```

Translation files are stored in a specific `i18n` folders, in the packages directory which entities belong to.
**Generic filename format** is : `packages/{package_name}/i18n/{lang}/{class_name}.json`

Translation files are requested  using the config_i18n controller:

Example : 
```bash
./equal.run --get=config_i18n --entity=core\User --lang=fr
```




## Translation of objects fields values

All basic fields can be translated (see Fields types).
To allow this, a table in DB is dedicated to the translation terms.
When a field is marked as **multilang**, the values of its translations can be retrieved with a SQL query.

**'Translation' object fields:**

```
string lang (code ISO 639-1)
string object_class
string object_field
integer object_id
mediumblob value
```

For the value field, the SQL MEDIUMBLOB type is used (overhead of 3 bytes, max size of 16,7 Mo).

Indeed, the size of the 'value' column may vary greatly from one type to another (the binary type may represent a document, a picture, a video, …). And, most of the time, fields that must be translated are texts (string, short_text or text). In any case, a 3 characters overhead is acceptable (and set a 16 Mo limit should not be a problem).

Note : as the only condition for the SQL type is to be compatible with the associated easyObject type, one must pay attention, in order for a binary field to be translated (for instance a PDF doc available in different languages), that the value of this field never has a greater size to the one of the SQL MEDIUMBLOB type (by example : BLOB, LONGBLOB, …).



#### Using multilang in CRUD

Before anything, the **multilang** field must be set to **true** in each Object's field **requiring** a translation. Like so :

```php
'field' => ['type' => 'string', 'multilang' => true]
```

To understand how it works, let's compare with a normal http **UPDATE** controller (which is also valid for CREATE)

```php
<?php
// [...]
MyObject::ids($id)
    	->update($fields)
        ->read(['field1', 'field2'])
        ->adapt('txt')->first();
```

Now let's use the multilang field by adding a parameter in our request

```php
<?php
// [...]
$lang = 'fr';
MyObject::ids($id)
    	->update($fields, $lang)
        ->read(['field1', 'field2'], $lang)
        ->adapt('txt')->first();
```

Adding a "lang" parameter will automatically convert all the multilang fields to the selected language

> Note: you don't need to specify language for a DELETE request since the whole object gets deleted

And it's the same process for a **GET** request, for instance :

```php
<?php
// [...]
$lang = 'en';
MyObject::search()
    	->read(['field1', 'field2'], $lang)
    	->adapt('txt')->get(true);
```

Now there is a special case you're very likely to encounter : **CREATE** an object with **multiple translations** at once.

Here is how you should proceed :

```php
<?php
// [...]
$lang1 = 'fr';
$lang2 = 'en';

MyObject::create($fields, $lang1)
    	->read(['field1', 'field2'])
    	->adapt('txt')->first();

MyObject::ids($id)->update($fields, $lang2);
```

What it does is updating your initial object with the secondary language

If you want to add more than 2 languages, you can repeat that last line for as many languages needed. 

Like so :

```php
<?php
// [...]
MyObject::ids($id)->update($fields, $lang2); // $lang2 = 'en'
MyObject::ids($id)->update($fields, $lang3); // $lang3 = 'es'
```

