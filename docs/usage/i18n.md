# Translations

Two distinct mechanisms are used depending on what we are handling:
1)	translation of the terms related to a class;
2)	translation of object fields values (instance).



## Translation of the terms related to a class

Each package can have an optional folder named ‘i18n’. If existing, this folder must contain a subfolder for each defined language. Subfolders use the ISO 639-1 language code as naming convention (ex. : *fr* or *zh*). Inside those folders, for each class, translations are stored in `.json` files which prefixes are identical to the class they refer to (ex. : `Student.json`).

Those translation files use UTF-8 encoding and JSON format, and contain the translation terms of all items that might be translated (attributes ‘label’, ‘description’ and ‘selection’, 'help').

The translation file has the `name` and the `plural` of the name of the class, as well as a `description` for it.  

The **model** section which consist of a map of all the field names that are present in the class, to which is associated a list of attributes with their related translations. 

Possible attributes are :   

* `label` attribute is the name of the field that we want the user to see and it must start with a capital letter. 

* `description` attribute is considered an additional information or a small brief for the field, to assist users in understanding the use of it. This attribute should start with a capital letter and end with either ".", "?" or "!". 

* `selection` attribute is usually added for the "type" field of the class, which allows the translation of the available options of the field.

* `help` attribute is going to be used as a more detailed explanation about the view's fields, in case the user didn't properly understand the `description`. For the moment, this attribute is going to be an empty string, but should be added to all the fields.

  The **view** section that translates all the section names of the tabs or the groups, if present in the form view. Since some classes may have multiple types of views, like "Partner.form.default.json" and "Partner.form.payer.json", this `view` section will contain the name of the type, in this case "form.default" and "form.payer". Inside each of these objects a `name`, a `description` and a `layout` containing the "id" of the view's sections and assigning a label to it, will be displayed as shown below. 

  ```json
  "view": {
          "form.default": {
              "name": "Partenaire",
              "description": "Formulaire de base pour afficher un partenaire",
              "layout": {}
          },
          "list.default": {
              "name": "Partenaires",
              "description": "Cette vue est destinée à afficher la liste de base des partenaires 										existants.",
              "layout": {}
          },
          "form.payer": {
              "name": "Client",
              "description": "Formulaire de base pour afficher un client (Partenaire)",
              "layout": {}
          },
          "list.customer": {
              "name": "Clients",
              "description": "Cette vue est destinée à afficher la liste de base des clients existants.",
              "layout": {}
          },
          "list.contact": {
              "name": "Contacts",
              "description": "Liste des contacts existants Partenaires.",
              "layout": {}
          }
      }
  ```

  In this example, multiple view type exists but all the layouts are empty because none of them were divided into sections. A none empty layout, which means that the view is actually divided into sections or tabs will look like so, where "section.identity_info", "section.identity_main_address", "section.identity_addresses", and "section.identity_description" are the sections ids and the `labels` are the name we want to be shown on the user side. Usually "list.default" type have an empty layout because it is a table, so will not be divided into sections.

  ```json
  "view": {
          "form.default": {
              "name": "Identité",
              "description": "Formulaire de base pour l'affichage du groupe.",
              "layout": {
                  "section.identity_info": {
                      "label": "Infos générales"
                  },
                  "section.identity_main_address": {
                      "label": "Adresse principale"
                  },
                  "section.identity_addresses": {
                      "label": "Autres adresses"
                  },
                  "section.identity_description": {
                      "label": "Description"
                  }
              }
          },
          "list.default": {
              "name": "Liste d'Identité",
              "description": "Cette vue est destinée à afficher la liste de base des identités 										existantes.",
              "layout": {}
          }
      }
  ```

  

The **error** section is used for translating the form validation (Usually added for the Login/Sign Up form).


### Example of french (fr) translation using i18n

```json
{
	"name": "Règle de Tva",
	"plural": "Règles de Tva",
	"description": "Les règles comptables permettent de préciser sur quel compte une opération doit être imputée.",
	"model": {
		"name":{"label":"Nom", "description": "Nom de la règle comptable.", "help": ""},
		"description":{"label":"Description", "description": "Brève description de la règle pour servir de mémo.", "help": ""},
		"type":{"label":"Type", "description": "Type d'opération auquel cette règle se rapporte.", "selection": {"purchase": "achat", "sale": "vente"}, "help": ""},
        "vat_rule_id":{"label":"Règle de TVA", "description": "Règle de TVA à laquelle cette ligne est liée.", "help": ""},
        "accounting_rule_line_ids":{"label":"Lignes liées à cette règle", "description": "Lignes liées à cette règle.", "help": ""}
	},
	"view": {
		"form.default": {
			"name": "Règles de Tva",
			"description": "Vue par défaut des règles comptables avec tous les champs",
			"layout": {
				"section.accounting_rules_section": {
					"label": "Détails"
				},
				"section.accounting_rulelines": {
					"label": "Ligne de règle comptable"
				}
			}
		},
		"list.default": {
			"name": "Liste des Règles de Tva",
			"description": "Cette vue est destinée à afficher les règles comptables.",
			"layout": {}
		}
	},
	"error": {
	
	}
}
```

Translation files are stored in a specific `i18n` folders, in the packages directory which entities belong to.
**Generic filename format** is : `packages/{package_name}/i18n/{lang}/{class_name}.json`

Translation files are requested  using the config_i18n controller:

Example : 
```bash
./equal.run --get=config_i18n --entity=core\User --lang=fr
```




## Translation of objects fields values

All basic fields can be translated (see Fields types).
To allow this, a table in DB is dedicated to the translation terms.
When a field is marked as **multilang**, the values of its translations can be retrieved with a SQL query.

**'Translation' object fields:**

```
string lang (code ISO 639-1)
string object_class
string object_field
integer object_id
mediumblob value
```

For the value field, the SQL MEDIUMBLOB type is used (overhead of 3 bytes, max size of 16,7 Mo).

Indeed, the size of the 'value' column may vary greatly from one type to another (the binary type may represent a document, a picture, a video, …). And, most of the time, fields that must be translated are texts (string, short_text or text). In any case, a 3 characters overhead is acceptable (and set a 16 Mo limit should not be a problem).

Note : as the only condition for the SQL type is to be compatible with the associated easyObject type, one must pay attention, in order for a binary field to be translated (for instance a PDF doc available in different languages), that the value of this field never has a greater size to the one of the SQL MEDIUMBLOB type (by example : BLOB, LONGBLOB, …).



#### Using multilang in CRUD

Before anything, the **multilang** field must be set to **true** in each Object's field **requiring** a translation. Like so :

```php
'field' => ['type' => 'string', 'multilang' => true]
```

To understand how it works, let's compare with a normal http **UPDATE** controller (which is also valid for CREATE)

```php
<?php
// [...]
MyObject::ids($id)
    	->update($fields)
        ->read(['field1', 'field2'])
        ->adapt('txt')->first();
```

Now let's use the multilang field by adding a parameter in our request

```php
<?php
// [...]
$lang = 'fr';
MyObject::ids($id)
    	->update($fields, $lang)
        ->read(['field1', 'field2'], $lang)
        ->adapt('txt')->first();
```

Adding a "lang" parameter will automatically convert all the multilang fields to the selected language

> Note: you don't need to specify language for a DELETE request since the whole object gets deleted

And it's the same process for a **GET** request, for instance :

```php
<?php
// [...]
$lang = 'en';
MyObject::search()
    	->read(['field1', 'field2'], $lang)
    	->adapt('txt')->get(true);
```

Now there is a special case you're very likely to encounter : **CREATE** an object with **multiple translations** at once.

Here is how you should proceed :

```php
<?php
// [...]
$lang1 = 'fr';
$lang2 = 'en';

MyObject::create($fields, $lang1)
    	->read(['field1', 'field2'])
    	->adapt('txt')->first();

MyObject::ids($id)->update($fields, $lang2);
```

What it does is updating your initial object with the secondary language

If you want to add more than 2 languages, you can repeat that last line for as many languages needed. 

Like so :

```php
<?php
// [...]
MyObject::ids($id)->update($fields, $lang2); // $lang2 = 'en'
MyObject::ids($id)->update($fields, $lang3); // $lang3 = 'es'
```

